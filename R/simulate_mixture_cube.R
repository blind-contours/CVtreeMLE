#' @title Simulate a mixture cube to test \code{CVtreeMLE} against simulated ground-truth.
#' @description Simulate a mixture cube. This creates three correlated mixture variables that are associated with two confounders W1 and W2. First mixtures are generated from a multivariate normal.
#' A multinomial outcome is generated based on betas input for W1 and W2 - associating each W with a part of the mixture cube. In each part of the mixture cube, transform the multivariate
#' normal mixture to a uniform distribution, respecting the bounds for parts of the cube. A three variable cube with one threshold per variable has 8 subspaces. An outcome is then generated
#' as a linear combination of different subspaces.
#'
#' @param n_obs Number of observations for which to generate data
#' @param splits Vector indicating where thresholds should be placed for each mixture variable
#' @param mins Vector indicating the minimum values for each mixture variable
#' @param maxs Vector indicating the maximum values for each mixture variable
#' @param mu Vector indicating the mean values for each mixture variable
#' @param sigma Matrix of the variance-covariance structure used to generate the mixture variables
#' @param w1_betas Vector of betas that define the subspace probability relationship with covariate W1
#' @param w2_betas Vector of betas that define the subspace probability relationship with covariate W2
#' @param mix_subspace_betas Vector of betas that define the subspace probabilities
#' @param subspace_assoc_strength_betas The outcome Y generated by each partition of the mixture cube
#' @param marginal_impact_betas Vector of betas that define the marginal impact each mixture variable has
#' @param eps_sd Random error included in the generation of Y
#' @param binary TRUE/FALSE depending on if the outcome should be binary


#' @importFrom data.table rbindlist
#' @importFrom dplyr group_by

#' @return Rules object. TODO: add more detail here.
#' @importFrom stats as.formula glm p.adjust plogis predict qlogis qnorm qunif rnorm runif
#' @importFrom dplyr mutate
#' @importFrom MASS mvrnorm
#' @importFrom rlang :=
#' @importFrom Hmisc rMultinom
#' @export


## levels reference for our mixture space:
# 0: All mixtures lower than specified thresholds
# 1: M1 is higher but M2 and M3 are lower
# 2: M2 is higher but M1 and M3 are lower
# 3: M1 and M2 are higher and M3 is lower
# 4: M3 is higher and M1 and M2 are lower
# 5: M1 and M3 are higher and M2 is lower
# 6: M2 and M3 are higher and M1 is lower
# 7: All mixtures are higher than thresholds


simulate_mixture_cube <- function(n_obs,
                                  splits,
                                  mins,
                                  maxs,
                                  mu,
                                  sigma,
                                  w1_betas,
                                  w2_betas,
                                  mix_subspace_betas,
                                  subspace_assoc_strength_betas,
                                  marginal_impact_betas,
                                  eps_sd,
                                  binary) {

  transform <- function(x){(x-min(x))/(max(x)-min(x))}
  barck_trans <- function(x, max, min){x*(max - min) + min}

  ## create multivariate normal which we are going to generate our correlated uniform
  ## for each mixture block

  rawvars <- mvrnorm(n=n_obs, mu=mu, Sigma=sigma)
  # CDF of these variables for mixture
  pvars <- stats::pnorm(rawvars)

  ## create a covariate
  W <- rnorm(n_obs, 0, 0.5)
  W2 <- rnorm(n_obs, 0, 0.5)

  ## probabilities
  b0i <- mix_subspace_betas
  b1i <- w1_betas
  b2i <- w2_betas

  probs_list <- c()

  for (i in seq(W)){

    w <- W[i]
    w2 <- W2[i]

    denominator <- sum(exp(b0i[2] + (b1i[2]*w) + (b2i[2]*w2)),
                       exp(b0i[3] + (b1i[3]*w) + (b2i[3]*w2)),
                       exp(b0i[4] + (b1i[4]*w) + (b2i[4]*w2)),
                       exp(b0i[5] + (b1i[5]*w) + (b2i[5]*w2)),
                       exp(b0i[6] + (b1i[6]*w) + (b2i[6]*w2)),
                       exp(b0i[7] + (b1i[7]*w) + (b2i[7]*w2)),
                       exp(b0i[8] + (b1i[8]*w) + (b2i[8]*w2)))

    a0 <- exp(b0i[1] + (b1i[1] * w) + (b2i[1] * w2)) / (1 + denominator)
    a1 <- exp(b0i[2] + (b1i[2] * w) + (b2i[2] * w2)) / (1 + denominator)
    a2 <- exp(b0i[3] + (b1i[3] * w) + (b2i[3] * w2)) / (1 + denominator)
    a3 <- exp(b0i[4] + (b1i[4] * w) + (b2i[4] * w2)) / (1 + denominator)
    a4 <- exp(b0i[5] + (b1i[5] * w) + (b2i[5] * w2)) / (1 + denominator)
    a5 <- exp(b0i[6] + (b1i[6] * w) + (b2i[6] * w2)) / (1 + denominator)
    a6 <- exp(b0i[7] + (b1i[7] * w) + (b2i[7] * w2)) / (1 + denominator)
    a7 <- 1 - sum(a0,a1,a2,a3,a4,a5,a6)

    probs_a <- c(a0, a1, a2, a3, a4, a5, a6, a7)

    probs_list[[i]] <- probs_a

  }

  probs_df <- as.data.frame(do.call(rbind, probs_list))
  colnames(probs_df) <- paste0("p", seq_len(ncol(probs_df)))

  probs <- probs_df %>% dplyr::select(p1:p8)

  res <- probs_df %>%
    dplyr::mutate(rcat = Hmisc::rMultinom(probs, 1))

  res <- as.data.frame(res)

  mixture_section_indicator <- expand.grid(c(0,1), c(0,1), c(0,1))
  colnames(mixture_section_indicator) <- c("M1", "M2", "M3")

  Ms <- as.data.frame(matrix(data = NA, ncol = 3, nrow = n_obs))
  colnames(Ms) <- c("M1", "M2", "M3")

  for (i in 1:nrow(mixture_section_indicator)) {
    ## iteration through the subspaces
    mix_space <- mixture_section_indicator[i,]

    ## 0 or 1 for for each mixture
    M1_01 <- mix_space[1]
    M2_01 <- mix_space[2]
    M3_01 <- mix_space[3]

    ## set high and low for M1
    if (M1_01 == 0) {
      m1_min <- mins[1]
      m1_max <- splits[1]
    } else{
      m1_min <- splits[1]
      m1_max <- maxs[1]
    }

    ## set high and low for M2
    if (M2_01 == 0) {
      m2_min <- mins[2]
      m2_max <- splits[2]
    } else{
      m2_min <- splits[2]
      m2_max <- maxs[2]
    }

    ## set high and low for M3
    if (M3_01 == 0) {
      m3_min <- mins[3]
      m3_max <- splits[3]
    } else{
      m3_min <- splits[3]
      m3_max <- maxs[3]
    }

    unifvars <- qunif(pvars, min = 0, max = 1)

    M1_sec <- barck_trans(unifvars[,1], min = m1_min, max = m1_max)
    M2_sec <- barck_trans(unifvars[,2], min = m2_min, max = m2_max)
    M3_sec <- barck_trans(unifvars[,3], min = m3_min, max = m3_max)

    subspace_data <- cbind(M1_sec, M2_sec, M3_sec)

    Ms[res$rcat == paste("p", i, sep = ""),] <- subspace_data[res$rcat == paste("p", i, sep = ""),]
  }

  ## here we create new data for the marginals -if marginals are used the mixture should not be used, this is done to test if tmle3mixrules currently identifies no rule
  unifvars <- qunif(pvars, min = 0, max = 1)

  M1_marg <- barck_trans(unifvars[,1], min = mins[1], max =  maxs[1])
  M2_marg <- barck_trans(unifvars[,2], min = mins[2], max =  maxs[2])
  M3_marg <- barck_trans(unifvars[,3], min = mins[3], max =  maxs[3])

  m1_marg <- ifelse(M1_marg > splits[1], 1,0)
  m2_marg <- ifelse(M2_marg > splits[2], 1,0)
  m3_marg <- ifelse(M3_marg > splits[3], 1,0)

  if(binary == TRUE) {
    y <-
      stats::plogis(subspace_assoc_strength_betas[1] +
                      subspace_assoc_strength_betas[2] * as.numeric(res$rcat == "p2") +
                      subspace_assoc_strength_betas[3] * as.numeric(res$rcat == "p3") +
                      subspace_assoc_strength_betas[4] * as.numeric(res$rcat == "p4") +
                      subspace_assoc_strength_betas[5] * as.numeric(res$rcat == "p5") +
                      subspace_assoc_strength_betas[6] * as.numeric(res$rcat == "p6") +
                      subspace_assoc_strength_betas[7] * as.numeric(res$rcat == "p7") +
                      subspace_assoc_strength_betas[8] * as.numeric(res$rcat == "p8") +
                      marginal_impact_betas[1] * m1_marg +
                      marginal_impact_betas[2] * m2_marg +
                      marginal_impact_betas[3] * m2_marg +
                      W +
                      W2 +
                      rnorm(length(res$rcat), mean = 0, sd = eps_sd))

    y <- ifelse(y > 0.50, 1,0)

  } else{
    y <-
      ## section for mixture subspaces
      subspace_assoc_strength_betas[1] +
      subspace_assoc_strength_betas[2] * as.numeric(res$rcat == "p2") +
      subspace_assoc_strength_betas[3] * as.numeric(res$rcat == "p3") +
      subspace_assoc_strength_betas[4] * as.numeric(res$rcat == "p4") +
      subspace_assoc_strength_betas[5] * as.numeric(res$rcat == "p5") +
      subspace_assoc_strength_betas[6] * as.numeric(res$rcat == "p6") +
      subspace_assoc_strength_betas[7] * as.numeric(res$rcat == "p7") +
      subspace_assoc_strength_betas[8] * as.numeric(res$rcat == "p8") +
      marginal_impact_betas[1] * m1_marg +
      marginal_impact_betas[2] * m2_marg +
      marginal_impact_betas[3] * m2_marg +
      W +
      W2 +
      rnorm(length(res$rcat), mean = 0, sd = eps_sd)

  }

  obs <- as.data.frame(cbind(W, W2, Ms, y))

  return(obs)
}
